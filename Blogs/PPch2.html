<DOCTYPE html>
<html>
  <head>
    <title> My Blog </title>
    </head>
    <body>
      <p>
      David Terkula
      </p>
      <p>
Writing Code for the Future
    </p>
    <p>
My big takeaways from chapter two center future oriented development and making things for yourself, and your team,
throughout the life span of your project. Some important aspects of writing flexible code include the practice of
decoupling where possible, designing projects and modules orthogonally, writing (fairly) reversible code, and using
prototypes. Each of these things can make developers lives easier when expectations change in the future.
</p>
<p>
Decoupling, especially of classes, is important for programming for handling changes in the future and maintaining one’s code.
Decoupling is the practice of writing classes that are independent of one another. Decoupling is important because if something
fails in one class, the problem is isolated and shouldn’t exist elsewhere in the program or application. If, for instance, a
value or some logic needs to be changed, it should only be needed to be changed in one spot. If not, then each class is not
mapped to its own logical entity and the program should be restructured. Decoupling removes a big source of duplication code
that makes maintaining code difficult, especially for maintenance programmers, who may not know immediately where everything
needs to be changed.
</p>
<p>
Creating orthogonally designed applications is similar to decoupling in its effects on benefits for creating flexible programs.
Orthogonal designs are characterized by independence across systems such that changes in one have no bearing on the other, much
like decoupling. Each system operates on a different axis so to speak; this allows each programmer or team to know exactly what
they are working on and won’t write code that will inhibit or rewrite what another team or member wrote. Creating programs this
way also promotes code reusability which can make future problems simpler if they are of a similar nature. Also, just from a
nerdy standpoint, one can get more functionality per unit of code if the design is purely orthogonal which makes for efficient
coding and design.
</p>
<p>

Writing flexible code that can be easily reversed or adapted to new expectations or requirements is the epitome of designing for
the future. Things will always change in the future, and perhaps a more efficient method will be introduced or discovered; how
much time and money you can save may be determined by how quickly your code can adapt to a new implementation. If you only have
to change some abstract design issues instead of many low level tedious changes, then your code will be more flexible and adaptable.
There is more than one way to solve a problem, and if your code can be easily adapted to more of those solutions, than your code will
be more useful in the future when it may be profitable or desirable to switch methods.
      </p>
      <p>
Prototyping can also be beneficial for the future, especially in terms of knowledge gained about how to tackle problem. Prototyping
allows developers to analyze the future problems they reach in the future before the program reaches that stage of functionality and
can help them be avoided. Prototyping typically involves writing disposable code that developers know will be thrown away so they can
test certain cases of data without worrying about error handling or testing the code for every possible set of input, but only the
ones they are currently interested in.
      </p>
      <p>
While I found most of this chapter useful, I found some parts confusing, specifically the section on “tracer bullet” code. I
couldn’t follow specifically what this does for or what this practice does for developers. I was also perplexed by the notion of
writing developers writing their own “mini languages” to match the domain of a problem. Perhaps we will talk about these later in
class. 
      </p>

      </body>
</html>
